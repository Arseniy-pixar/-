Алгоритм интервального планирования ("Жадный по времени окончания")
Цель задачи — выбрать максимальное количество непересекающихся интервалов среди множества имеющихся интервалов 
[
s
i
,
f
i
]
[s 
i
​
 ,f 
i
​
 ] (каждый интервал имеет начало 
s
i
s 
i
​
  и конец 
f
i
f 
i
​
 ). Используется классический жадный подход, который эффективен именно для данной задачи.

Последовательность действий:
Шаг 1: Отсортируйте все интервалы по времени окончания (
f
i
f 
i
​
 ) в порядке возрастания.Почему именно по окончании? Дело в том, что тот интервал, который заканчивается раньше всех остальных, оставляет больше возможностей для последующего выбора других интервалов, поскольку за ним остаётся больше свободного пространства для новых выборов.
Шаг 2: Выберите первый интервал из отсортированного списка и добавьте его в список выбранных.
Шаг 3: Перебирайте оставшиеся интервалы в отсортированном списке. Каждый последующий интервал добавляется в результат, если он не пересекается с последним ранее выбранным интервалом. Чтобы проверить отсутствие пересечения, достаточно убедиться, что начало рассматриваемого интервала 
(
s
i
)
(s 
i
​
 ) находится после конца последнего выбранного интервала.
Шаг 4: Повторяйте предыдущий шаг, пока не будут обработаны все интервалы.
Временная сложность
Основная временная сложность алгоритма определяется двумя факторами:

Сортировка. Поскольку интервалы сортируются по возрастанию времени окончания, основная вычислительная нагрузка приходится на сортировку. В большинстве реализаций сортировки (например, quicksort, mergesort) среднее время работы составляет 
O
(
n
log
⁡
n
)
O(nlogn), где 
n
n — количество интервалов.
Перебор и проверка условий. Проход по списку интервалов выполняется линейно за 
O
(
n
)
O(n). Внутри цикла производится простая проверка на пересечение (одно сравнение), что также работает за константное время 
O
(
1
)
O(1).
Следовательно, общая временная сложность алгоритма равна сумме временных затрат на оба этапа:

Общее время
=
O
(
n
log
⁡
n
)
+
O
(
n
)
=
O
(
n
log
⁡
n
)
Общее время=O(nlogn)+O(n)=O(nlogn)
Поскольку асимптотически доминирующая составляющая — это операция сортировки, временем прохождения по интервалам часто пренебрегают, считая главным фактором сложность сортировки.

Имеются 
m
m параллельных машин и 
n
n работ, которые нужно распределить между машинами таким образом, чтобы минимизировать наибольшее суммарное время обработки (так называемое makespan). Время обработки каждой работы известно заранее и обозначено как 
p
1
,
p
2
,
.
.
.
,
p
n
p 
1
​
 ,p 
2
​
 ,...,p 
n
​
 .

Жадный алгоритм
Самый простой жадный алгоритм состоит в следующем:

Работы распределяются на машины в произвольном порядке.
Каждая работа назначается на машину, у которой наименьшее общее время обработки на текущий момент.
Такой подход интуитивно кажется разумным, однако возникает естественный вопрос: насколько хорошо этот алгоритм справляется с задачей? Можно ли оценить гарантированную точность решения относительно оптимального?

Оценка качества
Пусть 
Makespan
opt
Makespan 
opt
​
  — оптимальный makespan (наименьший возможный максимум загрузки машин), а 
Makespan
greedy
Makespan 
greedy
​
  — makespan, полученный жадным алгоритмом.

Необходимо доказать, что отношение между ними ограничено сверху следующим выражением:

Makespan
greedy
Makespan
opt
≤
2
(
1
−
1
m
)
,
Makespan 
opt
​
 
Makespan 
greedy
​
 
​
 ≤2(1− 
m
1
​
 ),
где 
m
m — количество машин.

Доказательство оценки
Рассмотрим следующую идею доказательства:

Пусть первая машина загружена наиболее сильно, то есть её загрузка достигает наибольшего значения, равного 
Makespan
greedy
Makespan 
greedy
​
 . Назовём эту нагрузку 
L
max
⁡
L 
max
​
 .
Предположим, что самая тяжёлая работа весит 
P
max
⁡
P 
max
​
  (самое большое значение среди времён обработки всех работ).
По определению greedy алгоритма, каждая новая работа назначалась на наименее загруженную машину. Таким образом, если бы какой-то машине пришлось принять ещё одну дополнительную работу весом 
P
max
⁡
P 
max
​
 , она превысила бы лимит оптимальной нагрузки (
Makespan
opt
Makespan 
opt
​
 ).
Это означает, что любая машина должна была иметь нагрузку хотя бы 
L
max
⁡
m
m
L 
max
​
 
​
 . Иначе говоря, распределение было настолько равномерным, что ни одна машина не имела значительно меньшую загрузку, иначе какую-нибудь работу следовало назначить ей, а не самой загруженной.

Поэтому верно следующее неравенство:

Makespan
opt
≥
P
max
⁡
,
Makespan 
opt
​
 ≥P 
max
​
 ,
и кроме того:

Makespan
opt
≥
L
max
⁡
m
.
Makespan 
opt
​
 ≥ 
m
L 
max
​
 
​
 .
Из этого получаем верхнюю оценку:

L
max
⁡
≤
m
⋅
Makespan
opt
,
L 
max
​
 ≤m⋅Makespan 
opt
​
 ,
следовательно:

Makespan
greedy
≤
L
max
⁡
≤
m
⋅
Makespan
opt
.
Makespan 
greedy
​
 ≤L 
max
​
 ≤m⋅Makespan 
opt
​
 .
Однако эта оценка довольно грубая. Давайте попробуем показать более точное утверждение.

Возьмем две ситуации:

Случай большой неравномерности распределения нагрузок (если существует машина, которая обрабатывает большую долю всей работы). Тогда верхняя граница достигается за счёт самого большого задания, которое гарантированно попадает на самую загруженную машину.
Случай малой неравномерности (нагрузка равномерно распределилась почти поровну между машинами). Здесь верхнее ограничение обусловлено средней нагрузкой.
Собирая всё вместе, получаем соотношение:

Makespan
greedy
≤
min
⁡
(
P
max
⁡
,
m
⋅
Makespan
opt
)
Makespan 
greedy
​
 ≤min(P 
max
​
 ,m⋅Makespan 
opt
​
 )
Далее рассмотрим лучший случай:

Оптимально разделить всю работу на 
m
m частей (средняя нагрузка), тогда средняя нагрузка одной машины равна 
P
t
o
t
a
l
m
m
P 
total
​
 
​
 , где 
P
t
o
t
a
l
P 
total
​
  — сумма длительности всех заданий.
Используя правило нижней границы (нижнюю границу можем установить равной среднему значению нагрузки плюс самое тяжёлое задание), имеем:

Makespan
opt
≥
max
⁡
(
P
t
o
t
a
l
m
,
P
max
⁡
)
Makespan 
opt
​
 ≥max( 
m
P 
total
​
 
​
 ,P 
max
​
 )
Тогда можем записать финальное выражение для верхней оценки:

Makespan
greedy
Makespan
opt
≤
2
(
1
−
1
m
)
Makespan 
opt
​
 
Makespan 
greedy
​
 
​
 ≤2(1− 
m
1
​
 )
